(function(win) {

    function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }
    
    function CompressedFile(name, size, path, archiveRef) {
        this._name = name;
        this._size = size;
        this._path = path;
        this._archiveRef = archiveRef;
    }

    _proto = CompressedFile.prototype;

    _proto.name = function() {
        return this._name;
    };

    _proto.size = function() {
        return this._size;
    };

    _proto.extract = function() {
        return this._archiveRef.extractSingleFile(this._path);
    };

    function Archive(file, options, resolve, reject) {
        this._worker = new Worker(options.workerUrl);
        this._worker.addEventListener('message', this._workerMsg.bind(this));
        this._callbacks = [];
        this._content = {};
        this._processed = 0;
        this._file = file;
        this._resolve = resolve;
        this._reject = reject;
    }

    _proto = Archive.prototype;
    var _options;

    Archive.init = function(options) {
        if (options === void 0) {
            options = {};
        }

        _options = {
            workerUrl:'/js/libarchive-worker-1.3.0.min.js',
        };
        
        var o = Object.getOwnPropertyNames(options);
        o.forEach(function(n) {
            _options[n] = o[n];
        });
        
        return _options;
    };

    Archive.open = function(file, resolve, reject, options) {
        if (options === void 0) {
            options = null;
        }

        options = options || _options || Archive.init() && console.warn('Automatically initializing using options: ', _options);
        var arch = new Archive(file, options, resolve, reject);
        arch._open();
    };


    _proto._open = function() {
        var _this = this;

        this._postMessage({
            type: 'HELLO'
        }, function(resolve, reject, msg) {
            if (msg.type === 'READY') {
                _this._postMessage({
                    type: 'OPEN',
                    file: _this._file
                }, function(resolve, reject, msg) {
                    if (msg.type === 'OPENED') {
                        resolve(_this);
                    }
                });
            }
        });
    };

    _proto.hasEncryptedData = function() {
        return this._postMessage({
            type: 'CHECK_ENCRYPTION'
        }, function(resolve, reject, msg) {
            if (msg.type === 'ENCRYPTION_STATUS') {
                resolve(msg.status);
            }
        });
    };

    _proto.usePassword = function(archivePassword) {
        return this._postMessage({
            type: 'SET_PASSPHRASE',
            passphrase: archivePassword
        }, function(resolve, reject, msg) {
            if (msg.type === 'PASSPHRASE_STATUS') {
                resolve(msg.status);
            }
        });
    };

    _proto.getFilesObject = function(resolve, reject) {
        var _this2 = this;
        this._resolve = resolve;
        this._reject = reject;

        if (this._processed > 0) {
            resolve(_this2._content);
        }

        return this._postMessage({
            type: 'LIST_FILES'
        }, function(resolve, reject, msg) {
            if (msg.type === 'ENTRY') {
                var entry = msg.entry;

                var _this2$_getProp = _this2._getProp(_this2._content, entry.path),
                    target = _this2$_getProp[0],
                    prop = _this2$_getProp[1];

                if (entry.type === 'FILE') {
                    target[prop] = new CompressedFile(entry.fileName, entry.size, entry.path, _this2);
                }

                return true;
            } else if (msg.type === 'END') {
                _this2._processed = 1;
                resolve(_this2._cloneContent(_this2._content));
            }
        });
    };

    _proto.getFilesArray = function() {
        var _this3 = this;

        return this.getFilesObject().then(function(obj) {
            return _this3._objectToArray(obj);
        });
    };

    _proto.extractSingleFile = function(target, resolve, reject) {
        this._resolve = resolve;
        this._reject = reject;
        return this._postMessage({
            type: 'EXTRACT_SINGLE_FILE',
            target: target
        }, function(resolve, reject, msg) {
            if (msg.type === 'FILE') {
                var file = new File([msg.entry.fileData], msg.entry.fileName, {
                    type: 'application/octet-stream'
                });
                resolve(file);
            }
        });
    };

    _proto.extractFiles = function(extractCallback) {
        var _this4 = this;

        if (this._processed > 1) {
            return Promise.resolve().then(function() {
                return _this4._content;
            });
        }

        return this._postMessage({
            type: 'EXTRACT_FILES'
        }, function(resolve, reject, msg) {
            if (msg.type === 'ENTRY') {
                var _this4$_getProp = _this4._getProp(_this4._content, msg.entry.path),
                    target = _this4$_getProp[0],
                    prop = _this4$_getProp[1];

                if (msg.entry.type === 'FILE') {
                    target[prop] = new File([msg.entry.fileData], msg.entry.fileName, {
                        type: 'application/octet-stream'
                    });

                    if (extractCallback !== undefined) {
                        setTimeout(extractCallback.bind(null, {
                            file: target[prop],
                            path: msg.entry.path
                        }));
                    }
                }

                return true;
            } else if (msg.type === 'END') {
                _this4._processed = 2;

                _this4._worker.terminate();

                resolve(_this4._cloneContent(_this4._content));
            }
        });
    };

    _proto._cloneContent = function(obj) {
        if (_instanceof(obj, File) || _instanceof(obj, CompressedFile) || obj === null) return obj;
        var o = {};

        for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
            var prop = _Object$keys[_i];
            o[prop] = this._cloneContent(obj[prop]);
        }

        return o;
    };

    _proto._objectToArray = function(obj, path) {
        if (path === void 0) {
            path = '';
        }

        var files = [];

        for (var _i2 = 0, _Object$keys2 = Object.keys(obj); _i2 < _Object$keys2.length; _i2++) {
            var key = _Object$keys2[_i2];

            if (_instanceof(obj[key], File) || _instanceof(obj[key], CompressedFile) || obj[key] === null) {
                files.push({
                    file: obj[key] || key,
                    path: path
                });
            } else {
                files.push.apply(files, this._objectToArray(obj[key], "" + path + key + "/"));
            }
        }

        return files;
    };

    _proto._getProp = function(obj, path) {
        var parts = path.split('/');
        if (parts[parts.length - 1] === '') parts.pop();
        var cur = obj,
            prev = null;

        for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i3 >= _iterator.length) break;
                _ref = _iterator[_i3++];
            } else {
                _i3 = _iterator.next();
                if (_i3.done) break;
                _ref = _i3.value;
            }

            var part = _ref;
            cur[part] = cur[part] || {};
            prev = cur;
            cur = cur[part];
        }

        return [prev, parts[parts.length - 1]];
    };

    _proto._postMessage = function(msg, callback) {
        var _this5 = this;

        this._worker.postMessage(msg);

        _this5._callbacks.push(_this5._msgHandler.bind(_this5, callback, this._resolve, this._reject));
    };

    _proto._msgHandler = function(callback, resolve, reject, msg) {
        if (msg.type === 'BUSY') {
            reject('worker is busy');
        } else if (msg.type === 'ERROR') {
            reject(msg.error);
        } else {
            return callback(resolve, reject, msg);
        }
    };

    _proto._workerMsg = function(_ref2) {
        var msg = _ref2.data;
        var callback = this._callbacks[this._callbacks.length - 1];
        var idx = this._callbacks.length - 1;
        
        var next = callback(msg);
        if(!next) {
            this._callbacks.splice(idx, 1);
        }
    };
    
    win.Archive = Archive;
})(window);